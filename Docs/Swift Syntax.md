
> [!question] GQ1. let vs varë¥¼ ì–´ë–»ê²Œ ì„ íƒí•´ì•¼ í• ê¹Œ?  
> [!question] GQ2. ìˆ«ìÂ·ë¬¸ìì—´ ë¦¬í„°ëŸ´ê³¼Â **íƒ€ì… ì¶”ë¡ **ì€ ì–´ë–»ê²Œ ë™ì‘í• ê¹Œ?  
> [!question] GQ3. if / guard / switch êµ¬ë¬¸ì€ ì–¸ì œ ê°ê° ì“°ëŠ” ê²ƒì´ ì¢‹ì„ê¹Œ?  
> [!question] GQ4. forâ€‘in, while ë°˜ë³µë¬¸ ì„±ëŠ¥Â·ê°€ë…ì„± ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤ëŠ”?  
> [!question] GQ5. í•¨ìˆ˜ ì„ ì–¸ ì‹œ ë§¤ê°œë³€ìˆ˜Â **ë¼ë²¨Â·ê¸°ë³¸ê°’**ì„ ì–´ë–»ê²Œ í™œìš©í•´ì•¼ í• ê¹Œ?

**Description**

- Swiftì˜ ê¸°ë³¸ ë¬¸ë²• ê°ê°ì„ ë‹¤ì ¸ ì´í›„ ì˜µì…”ë„, ì»¬ë ‰ì…˜, í”„ë¡œí† ì½œ ë“± ì‹¬í™” ê°œë… í•™ìŠµì˜ ê¸°ë°˜ì„ ë§ˆë ¨í•©ë‹ˆë‹¤. íŠ¹íˆÂ **ë¶ˆë³€Â·ê°€ë³€ ê°’ ê´€ë¦¬(let/var)**,Â **íƒ€ì… ì¶”ë¡  ê·œì¹™**,Â **ì œì–´ êµ¬ë¬¸ ì„ íƒ ê¸°ì¤€**,Â **ë°˜ë³µë¬¸ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤**,Â **í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ ì„¤ê³„**ë¥¼ ì‚¬ë¡€ ì¤‘ì‹¬ìœ¼ë¡œ ì²´ë“í•©ë‹ˆë‹¤.
    

**ì£¼ìš” ê¸°ëŠ¥**

- **ë¶ˆë³€(immutability) ê¸°ë°˜ ì•ˆì „ì„±**Â â€• let ì‚¬ìš©ìœ¼ë¡œ ìŠ¤ë ˆë“œ ë ˆì´ìŠ¤Â·ë…¼ë¦¬ ë²„ê·¸ ì˜ˆë°©
- **íƒ€ì… ì¶”ë¡  ìë™í™”**Â â€• ì»´íŒŒì¼ íƒ€ì„ì— íƒ€ì… í™•ì •, ê°€ë…ì„±Â·ì‘ì„± ì†ë„ í–¥ìƒ
- **ì œì–´ êµ¬ë¬¸ 3ë‹¨ê³„(ifâ†’guardâ†’switch)**Â â€• ê°€ë…ì„±ê³¼ ì˜¤ë¥˜ ë°©ì§€ ìµœì í™”
- **ì»¬ë ‰ì…˜ ë°˜ë³µ ìµœì (forâ€‘inÂ·enumerated)**Â â€• ì¸ë±ìŠ¤ ê´€ë¦¬ ì˜¤ë¥˜ ê°ì†Œ, ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ëŠ” while
- **ì˜ë¯¸ ìˆëŠ” í•¨ìˆ˜ ë¼ë²¨ + ê¸°ë³¸ê°’**Â â€• ì˜¤ë²„ë¡œë“œ ìµœì†Œí™”, í˜¸ì¶œë¶€ë¥¼ â€œë¬¸ì¥â€ì²˜ëŸ¼ ì„¤ê³„

---

### Q1. let vs varë¥¼ ì–´ë–»ê²Œ ì„ íƒí•´ì•¼ í• ê¹Œ?

| **ë‹¨ê³„**         | **ì‚¬ê³  ì ˆì°¨**                                                   | **ë©”ëª¨**                       |
| -------------- | ----------------------------------------------------------- | ---------------------------- |
| **â‘  ì˜ë„ íŒŒì•…**    | ê°’ì´Â **ë¶ˆë³€**(immutable)ì¸ê°€? â†’Â `let`Â ê°’ì´Â **ë³€í•  ê°€ëŠ¥ì„±**ì´ ìˆëŠ”ê°€? â†’Â `var` | SwiftëŠ” â€œê°€ëŠ¥í•œ í•œ ë¶ˆë³€â€ ê¶Œì¥         |
| **â‘¡ ì•ˆì „ì„± ê³ ë ¤**   | `let`Â ì‚¬ìš© ì‹œÂ **Thread SafetyÂ·Logic Bug**Â ì˜ˆë°© ìŠ¤ë ˆë“œ ì¶©ëŒÂ·ì‹¤ìˆ˜ ë®ì–´ì“°ê¸° ì°¨ë‹¨ | ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ íŠ¹íˆ ìœ ë¦¬             |
| **â‘¢ í¼í¬ë¨¼ìŠ¤**     | ì»´íŒŒì¼ëŸ¬ê°€Â `let`ì„ ë§Œë‚˜ë©´ ê³µê²©ì  ìµœì í™”(ë³µì‚¬ ì œê±°, ë ˆì§€ìŠ¤í„° ê³ ì •)                    | `var`ë„ ë¹ ë¥´ì§€ë§Œ ì ì¬ì  ë³€ê²½ ëŒ€ë¹„ ê²€ì‚¬ê°€ ì¶”ê°€ |
| **â‘£ ë¦¬íŒ©í„°ë§ ì‹œê·¸ë„** | `let â†’ var`Â ë³€ê²½ì´ ì¦ë‹¤ë©´Â **ëª¨ë¸ë§ ì˜¤ë¥˜**Â ì˜ì‹¬                           | ë¶ˆí•„ìš”í•œ ìƒíƒœ(state) íƒì§€            |

```swift
func testLetVar() {
    let title = "Swift"
    // title = "Rust"   // â›”ï¸ ì»´íŒŒì¼ ì˜¤ë¥˜
    var version = "5.9"
    version = "6.0"       // âœ… ê°€ë³€ ê°’ ìˆ˜ì •
    print(version)
}
```

> ğŸ’¡Â **ë¹„ìœ **  
> `let`Â ìƒì = â€œë°€ë´‰ëœ ì„ ë¬¼â€ â†’ ëœ¯ì„ ìˆ˜ ì—†ë‹¤.  
> `var`Â ìƒì = â€œì§€í¼ë°±â€ â†’ ì—´ê³  ë‚´ìš©ë¬¼ êµì²´ ê°€ëŠ¥.

---

### Q2. ìˆ«ìÂ·ë¬¸ìì—´ ë¦¬í„°ëŸ´ê³¼ íƒ€ì… ì¶”ë¡ ì€ ì–´ë–»ê²Œ ë™ì‘í• ê¹Œ?

|**ë‹¨ê³„**|**ë¬´ìŠ¨ ëœ»?**|**ì˜ˆì‹œ**|
|---|---|---|
|**â‘  ë¦¬í„°ëŸ´ í•´ì„**|42 â†’Â `Int`, "hi" â†’Â `String`, 3.14 â†’Â `Double`|`let a = 42`Â (Int)|
|**â‘¡ ì»¨í…ìŠ¤íŠ¸ ì¶”ë¡ **|ì¢Œë³€ íƒ€ì…Â·í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ ì°¸ê³ |`let x: UInt8 = 42`|
|**â‘¢ ì˜¤ë²„ë¡œë“œ í•´ê²°**|ê°€ì¥Â **êµ¬ì²´ì **Â íƒ€ì… í›„ë³´ ì„ íƒ|`printNum(3)`Â â†’Â `Int`Â ë²„ì „|
|**â‘£ ì„±ëŠ¥ & ì•ˆì „**|ì¶”ë¡ ì€ ì»´íŒŒì¼ íƒ€ì„Â·ëŸ°íƒ€ì„ ë¹„ìš© 0|ëª¨í˜¸í•˜ë©´ íƒ€ì… ëª…ì‹œ|

```swift
let intLit    = 42          // Int (64â€‘bit)
let doubleLit = 3.14        // Double
let greeting  = "hi"         // String

let byte: UInt8 = 42        // 42 âœ UInt8
func square(_ n: Int)    -> Int    { n * n }
func square(_ n: Double) -> Double { n * n }
print(square(5))   // 25, Int ë²„ì „
print(square(5.5)) // 30.25, Double ë²„ì „
```

---

### Q3. if / guard / switch êµ¬ë¬¸ì€ ì–¸ì œ ê°ê° ì“°ëŠ” ê²ƒì´ ì¢‹ì„ê¹Œ?

| **ì‚¬ìš© ìƒí™©**         | **ì¶”ì²œ êµ¬ë¬¸** | **ì´ìœ **                         |
| ----------------- | --------- | ------------------------------ |
| ì¡°ê±´ë¶€ íë¦„ & ì§§ì€ ë¶„ê¸°    | `if`      | ê°€ì¥ ì§ê´€ì                          |
| ì¡°ê¸° ë°˜í™˜(Early Exit) | `guard`   | ì‹¤íŒ¨ ë¶„ê¸° ìœ„ë¡œ ì˜¬ë ¤ ê°€ë…ì„±â†‘               |
| ë‹¤ì¤‘ ê°’ ë§¤ì¹­Â·íŒ¨í„´ ë¶„í•´     | `switch`  | enumÂ·íŠœí”Œ ë²”ìœ„ ë“± exhaustiveness ê²€ì‚¬ |

```swift
func fetch(id: Int?) throws -> Item {
    guard let id else { throw FetchError.invalidID }   // guardë¡œ ì‹¤íŒ¨ ì¡°ê¸° ë°˜í™˜
    return try network.load(id: id)
}
```

---

### Q4. forâ€‘in, while ë°˜ë³µë¬¸ ì„±ëŠ¥Â·ê°€ë…ì„± ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤ëŠ”?

|**ë¹„êµ í•­ëª©**|**forâ€‘in**|**while**|
|---|---|---|
|ê°€ë…ì„±|âœ… ì»¬ë ‰ì…˜ ìˆœíšŒ ì§ê´€ì |ë£¨í”„ ë³€ìˆ˜Â·ì¡°ê±´ ë¶„ë¦¬ í•„ìš” â›”ï¸|
|ì•ˆì „ì„±|âœ… ë²”ìœ„Â·ì»¬ë ‰ì…˜ ë ìë™ ì²˜ë¦¬|ì¸ë±ìŠ¤ ì´ˆê³¼Â·ë¬´í•œ ë£¨í”„ ìœ„í—˜|
|ì„±ëŠ¥|ë‘˜ ë‹¤ O(n) â†’ ì°¨ì´ ë¯¸ë¯¸|ë™ì¼|
|íŠ¹ìˆ˜ ìš©ë„|`for case let`Â íŒ¨í„´ ë§¤ì¹­,Â `for try await`|ì¡°ê±´ë¶€ ìŠ¤íŠ¸ë¦¼Â·ë¬´í•œ ë£¨í”„|

```swift
let fruits = ["ğŸ", "ğŸ‹", "ğŸ‘"]
for (idx, fruit) in fruits.enumerated() {
    print(idx, fruit)
}

var i = 0
while i < 3 {
    print("while loop", i)
    i += 1
}
```

---

### Q5. í•¨ìˆ˜ ì„ ì–¸ ì‹œ ë§¤ê°œë³€ìˆ˜ ë¼ë²¨Â·ê¸°ë³¸ê°’ì„ ì–´ë–»ê²Œ í™œìš©í•´ì•¼ í• ê¹Œ?

|**ë‹¨ê³„**|**ì‚¬ê³  ì ˆì°¨**|**ë©”ëª¨**|
|---|---|---|
|â‘  ë¼ë²¨ ê°€ë…ì„±|ì™¸ë¶€ ë¼ë²¨ì€Â **ë¬¸ì¥ì²˜ëŸ¼**Â ì½íˆê²Œ|`move(from:to:)`|
|â‘¡ ì²« ë§¤ê°œë³€ìˆ˜ ê·œì¹™|Swift 5.2+ë¶€í„° ì²« íŒŒë¼ë¯¸í„°ë„ ë¼ë²¨ ìˆìŒ(ìƒëµ ê°€ëŠ¥)|í•„ìš” ì‹œÂ `_`Â ë¡œ ìƒëµ|
|â‘¢ ê¸°ë³¸ê°’ ì œê³µ|ì˜µì…˜Â·í¬ê·€ ì˜µì…˜ â†’ ê¸°ë³¸ê°’ìœ¼ë¡œ API ê°„ì†Œí™”|ì˜¤ë²„ë¡œë“œ ëŒ€ì‹  ê¸°ë³¸ê°’|
|â‘£ Variadic & inout|ë‹¤ìˆ˜ ì¸ìÂ·ìˆ˜ì • í•„ìš” ì‹œ ì‚¬ìš©|ê¼­ í•„ìš”í•œ ê³³ì—ë§Œ|

```swift
func drawLine(from start: CGPoint,
              to end: CGPoint,
              dashed: Bool = false,
              width: CGFloat = 1.0) {
    // ...
}

drawLine(from: .zero, to: CGPoint(x: 10, y: 0))                 // ê¸°ë³¸ê°’ ì‚¬ìš©
```

---

**Keywords**

- let / var, immutability, thread safety, type inference, literal, if, guard, switch, early exit, forâ€‘in, enumerated, while, pattern matching, parameter label, default parameter, variadic, inout
    

**References**

- _The Swift Programming Language_Â â€” Basics, Control Flow, Functions (Swift.org)
- Apple Developer Documentation â€”Â _Swift Standard Library_
- WWDC21Â **â€œMeet async/await in Swiftâ€**
- WWDC22Â **â€œSwift: Modern Concurrency and Beyondâ€**